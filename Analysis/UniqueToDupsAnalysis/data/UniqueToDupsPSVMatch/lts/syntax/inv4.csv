"/*
All the states have the same events available.
*/",1
"State in",1
"Init^.trans",2
"all s : State",1
"let st = Node",1
"all s:State |",1
"State in Init.",1
"all s: State |",1
"all s1 : State |",1
"all State in Init",1
"State in Init.^tr",1
"State in Init.*tr",1
"Init in ^adj.State",1
"Init->State in *tr",2
"State in Init.^adj",3
"State in Init.*adj",8
"Init->State in ^tr",1
"Init in State.^adj",1
"Node in Init.*trans",1
"State in init.^trans",1
"States in init.^trans",1
"All s:State | s.^Init",1
"States = (Init.^trans)",1
"State = Init.^function",1
"all s: State | s^.trans",1
"State in e.(Init.trans)",1
"Init.^function in State",1
"State in Init.^function",1
"State-Init in Init.*adj",1
"State in fromState[Init]",1
"State in e.(Init.^trans)",1
"State in Init.lookupState",2
"all s : State | one Intit",1
"State in Init.^onlyStates",1
"State in Init.Trans.Event",1
"State in Init.trans..trans",1
"State in State.lookupState",1
"State in Init.^lookupState",10
"range[(Init.trans)] = State",1
"Event^.(Init.trans) = State",1
"State in Init.^(trans[Etat])",1
"all s:State | s in Init.^adj",2
"all s:State | Init in s.^adj",1
"all s: State | Init^.function",1
"for all i : Initial | trans.i",1
"State in Event.^(Init.trans).",1
"all i : Init | State in i.*adj",1
"all s : State | s in Init.*adj",1
"State in Events. (Init.^trans)",1
"all s: State | s in Init.trans^",1
"all s: State | Init in trans*.s",1
"all i : Init | State in i . ^adj",1
"all i : Init | State in i . *adj",1
"all s1 : State |  ^(Init.trans).s",1
"all s:State | s in :>(Init.trans)",1
"all s: State | Init in (trans.s)*",1
"State in Init + Init.^lookupState",1
"all i : Initial | State in i.trans",2
"State in fromState[Init].fromState",1
"no ((States - Init)-(trans.~trans))",1
"all s : State | some Initial.^trans",1
"((init.trans)^[Event]).trans[Event]",1
"for all i : Initial | trans.Initial",4
"all s : State | s in Init.reachable",3
"all s : State | s in reachable[Init]",1
"all s : State | s in Init.^reachable",1
"all i : Init, s : State | s in i.*tr",3
"all s : State | s in Init.*reachable",2
"State in (fromState[Init]).fromState",1
"all s : State | State in e.(s.^trans)",2
"all s:State-Init| some e:Event | s in",2
"all s : State | s in Init.^onlyStates",4
"all s : State | s in Init. (reachable)",1
"all s : State | s in Init. *(reachable)",1
"all e : Event | State = r.^(Init.trans)",1
"all s:State-Init | s in ^(trans.e).Init",1
"all s:State | some i:Init | s in i.^succ",2
"all s: State | some i: Init |some i.^adj",1
"State in Event.(Event(Init.trans.trans))",1
"all x : Init | Node in (*(x.trans)).Event",1
"all s: State | some i: Init | s in i.^adj",1
"(all s:State | some i:Init | s in i.^succ)",1
"all s : State | some i: Init | s in i.^adj",1
"all s:State, some i:Init | s in i->Event->s",1
"State in ((init.trans)[Event]).trans[Event]",1
"State in ((init.trans)^[Event]).trans[Event]",1
"all s:State, i:Init |  some (i.^trans :< s )",1
"all x : Init | State in lone Event.*(x.trans)",1
"for s: State | some e: Event | (Init.trans).e",1
"all s : State | s in Init.reachable.reachable",2
"for s: State | some i: Init | i in trans.s.Event",1
"for s: State | some i: Init | i in trans.s.Event",1
"all i:Init | some e:Event | State in e.(i.*tras)",2
"all e : Event | State = Init + ((e.Init).^trans))",1
"all s : Init <: trans | State in n.^(trans.Event)",1
"some e:Event, some s:State| Init in ^trans.(e->s)",1
"all s: State | some i: Init | i in  Event.(trans.s)",2
"all x : Init, all y : Event | State in *(x.trans).y",1
"all s:State |some e:Event | s in e.^(Initial.trans)",2
"all s: State | some i: Init | i in  Event.(trans.s)",1
"let adj={x,y:State | some e:Event |x->e->y in trans}",1
"all s:State-Init| some e:Event | s in Init.trans^[e]",1
"all s: State | some e: Event | all e->s in Init.trans",1
"all s : State | let r[x] = x.tran[Event] | s in Init.*r",1
"all s : State | s in Init.reachable.reachable.reachable",2
"let adj =  {x,y:State | some e:Event | x->e->y in trans}",1
"let ts : onlyStates[] |
  		all s : State | s in Init.^ts",1
"let adj =  ({x,y:State | some e:Event | x->e->y in trans})",1
"all s : State | s in Init && State in ^(s->Event.(n.trans))",1
"for s: State | some e: Event | (Init.trans).^(Event->State)",1
"let adj = ( all x,y:State | some e:Event | x->e->y in trans )",1
"all e : Event | State = Init + (e.^(Init.trans))

/*
All the states have the same events available.
*/",1
"all s : State | s in Init.reachable.reachable.reachable.reachable",1
"Initial.{s1 : State, s2 : State | s1->Event->s2 in trans} = State",1
"Init.*({x: State, y: State | any e: Event | x.trans[e] = y}) = State",1
"let adj = ( all x,y:State | some e:Event | x->e->y in trans )
  	^adj",2
"all s: State.trans.Event | s.^{y,x: State | some x.trans.y} = Initial",1
"let r = {State->(State.trans.e) | e in Event} | 
	 		State in Init.^r",2
"all  s : (State - Init)  | some e:Event |  some ( Init & trans^.(e->s)",1
"let r = {State->(State.trans.e)| all e: Event} | 
	 		State in Init.^r",1
"Init.*({x: State, y: State | (any e: Event | x.trans[e] = y) }) = State",1
"let r = {all e: Event | State->(State.trans.e)} | 
	 		State in Init.^r",1
"all  s : (State - Init)  | some e:Event |  some ( Init & trans^.(e->s) )",2
"all u : Init | Node in  u.*{ x : State, y : State | x->Event->y in trans}",1
"let r = {State->(State.trans.e)| all: e in Event} | 
	 		State in Init.^r",1
"all s: State | some (*{s1, s2: State | some (s2 <: trans :> s1}.s & Init)",1
"let adj = {s1,s2: State | some e s1.e.s2}
  all s: State | some i: Init | s in ^adj",1
"let trans_bin = {s1 : State, s2 : State | some s1.trans.s2}
    Init.*trans_bin = State",1
"let t = { s1,s2 : State | some e : Event | s1->e->s2  in trans } |
  	State in Init.(^t})",1
"let adj = {s1,s2: State | s1 -> e -> s2 in trans}
  all s: State | some i: Init | s in ^adj",1
"let adj={x,y:State | some e:Event |x->e->y in trans}
  
  all i:Init |(State-Init) in i.^adj",3
"all x : Init | Node in x.*(trans.Event)

/*
All the states have the same events available.
*/",1
"let t = { all s1,s2 : State | some e : Event | s1->e->s2  in trans } |
  	State in Init.(^t})",2
"all x : Init  | Node in x.*(trans.Event)

/*
All the states have the same events available.
*/",1
"let t = {all x,y : State, some z : Event | x->z->y in trans}
	all s : State | some Init.(s.^t)",2
"all x : Init | Node in (*(x.trans)).Event

/*
All the states have the same events available.
*/",1
"let t = {all x,y : State, some z : Event | x->z->y in trans}|
	all s : State | some Init.(s.^t)",1
"no Init  implies no State and (some e:Event | all s:(State-Init) | some(Init & trans^.(e->s)) )",1
"all e : Event | State = (e.(Init.^trans))

/*
All the states have the same events available.
*/",1
"all e : Event | State = (e.^(Init.^trans))

/*
All the states have the same events available.
*/",1
"let t = {all x,y : State, some z : Event | x->z->y in trans} |
	all s : State | some Init.(s.^t)",1
"let t = { x : State, y : State | some e : Event | x->e->y in trans}
  all u : Init | State in u.*t",1
"let t = { x : State, y : State | some e : Event | x->e->y in trans},
  all u : Init | State in u.*t",1
"all x : Init, y : State | Node x.*(trans.Event)

/*
All the states have the same events available.
*/",1
"}

fun f[t : trans] : State->State {
	{s1->s2 : State->State | s1 in trans.univ and s2 in univ.trans}",1
"let t = { x : State, y : State | some e : Event | x->e->y in trans} |
  some e : Init | Node in e.(^t)",1
"let t = {all x,y : State, some z : Event | x->z->y in trans}
	all s : State | State in Init.*(s.trans)",1
"all e : Event | State = Init + (e.^(Init.^trans))

/*
All the states have the same events available.
*/",1
"let adj = {s1,s2: State | some e: Event | s1 -> e -> s2 in trans}
  all s: State | some i: Init | s in ^adj",1
"Init.*trans_bin = State
}

fun trans_bin : State -> State {
    {s1:Book, s2:Addr | s1->Event->s2 in trans }",1
"one Init
}

fun f[t : trans] : State->State {
	{s1->s2 : State->State | s1 in trans.univ and s2 in univ.trans}",1
"State in Init.(^onlyStates)
}

fun onlyStates : set State -> State {
  s1,s2: State | some e: Event | s1->e->s2 in trans",1
"State = Init.(^onlyStates)
}

fun onlyStates : set (State -> State) {
  { (s1, s2) : State | some e : Event | s1->e->s2 in trans }",1
"x and (all s:State | some i:Init | s in i.^succ)
}

pred x{
	all s1,s2:State | s1->s2 in succ iff some y:Event | s1->y->s2 in trans",1
"all s1,s2 : State | some e : Event | s1->e->s2  in trans
  	State in Init.(^( s1,s2 : State | some e : Event | s1->e->s2  in trans))",1
"x implies all s:State | some i:Init | s in i.^succ
}

pred x{
	all s1,s2:State | s1->s2 in succ iff some y:Event | s1->y->s2 in trans",1
"x implies (all s:State | some i:Init | s in i.^succ)
}

pred x{
	all s1,s2:State | s1->s2 in succ iff some y:Event | s1->y->s2 in trans",1
"all s : State | s in Init.*tran
}

/*
All the states have the same events available.
*/
fun tran[s : State] : set State {
  s.trans[Event]",1
"State in ^fromState[Init]
}

/*
All the states have the same events available.
*/
fun fromState[s1: State] : set State {  
	s1.trans[Event]",1
"all s : State | s in Init.*tran1
}

/*
All the states have the same events available.
*/
fun tran1[s : State] : set State {
  s.trans[Event]",1
"all s : State | s in Init.*tran1
}

/*
All the states have the same events available.
*/
fun tran1 (s : State) : set State {
  s.trans[Event]",1
"State in Init.^lookupState
}

/*
All the states have the same events available.
*/
fun lookupState[s: set State] : set State {  
	s.trans[Event]",3
"all s : State | s in Init.*reachable
}

/*
All the states have the same events available.
*/
fun reachable[s : State] : set State {
  s.trans[Event]",1
"all s : State | s in Init .* reachable
}

/*
All the states have the same events available.
*/
fun reachable[s : State] : set State {
  s.trans[Event]",1
"State in fromState[Init].^fromState
}

/*
All the states have the same events available.
*/
fun fromState[s: set State] : set State {  
	s.trans[Event]",1
"all s : State | s in Init. *(reachable)
}

/*
All the states have the same events available.
*/
fun reachable[s : State] : set State {
  s.trans[Event]",1
"State in (fromState[Init]).^fromState
}

/*
All the states have the same events available.
*/
fun fromState[s: set State] : set State {  
	s.trans[Event]",1
"all s: State | Init.^function(s)
}

/*
All the states have the same events available.
*/
fun function(s: State): State->State {
  {s1, s2: State | s1->Event->s2 in trans}",1
"all s: State | Init.^function[s]
}

/*
All the states have the same events available.
*/
fun function[s: State]: State->State {
  {s1, s2: State | s1->Event->s2 in trans}",1
