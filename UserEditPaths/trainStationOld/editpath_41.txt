NA H: THEME UPDATE
prop1 C: no Green
prop2 B: eventually some Green
prop2 B: always eventually some Green
prop2 C: all s : Signal | eventually s in Green
prop2 C: all s : Signal | eventually s in Green
prop2 O: eventually historically Green = Signal
prop2 O: eventually historically Signal in Green
prop2 O: historically eventually Signal in Green
prop2 C: all s : Signal | eventually s in Green
prop3 T: all t : Track | always t.pos
prop3 U: all t : Track | always lone t.pos
prop3 U: always all t : Track | always lone t.pos
prop3 U: always all t : Track | lone t.pos
prop3 S: always t : Track | lone pos.t
prop3 B: always all t : Track | lone pos.t
prop3 B: always pos.~pos in iden
prop3 U: always ~pos.pos in iden
prop3 U: always after ~pos.pos in iden
prop3 U: always ~pos.pos in iden
prop3 U: always ~pos.pos in iden
prop3 S: always ~pos.pos in iden and always all t : Train | lone t.pos
prop3 U: always ~pos.pos in iden and (always all t : Train | lone t.pos)
prop3 U: always ~pos.pos in iden and (always all t : Train | always lone t.pos)
prop3 T: always pos
prop3 S: always pos = after pos
prop3 S: always pos in after pos
prop3 S: always (pos = after pos)
prop3 S: always all t : Train | (t.pos = after t.pos)
prop3 S: always all t : Train | (t.pos = after t.pos)
prop3 S: always all t : Train | (t.pos in after t.pos)
prop3 S: always all t : Train | t.pos in after t.pos
prop2 C: all s : Signal | eventually s in Green
prop3 U: always all t : Train | lone t.pos
prop3 S: False releases always pos
prop3 S: false releases always pos
prop3 S: no releases always pos
prop3 S: no releases pos
prop3 S: always pos = after pos
prop3 U: always (Train->Track - pos) + pos = (Train->Track - pos) + pos
prop3 U: always ((Train->Track - pos) + pos) = ((Train->Track - pos) + pos)
prop3 U: always pos = pos
prop3 S: always pos = pos and no pos in no pos
prop3 T: always pos = pos and (Train->Track not in pos) = (Train->Track not in pos)
prop3 U: always pos = pos and (Train.pos not in Track implies always Train.pos not in Track)
prop3 U: always pos = pos and (all t : Train | t.pos not in Track implies always t.pos not in Track)
prop3 U: always pos = pos and (all t : (Train - pos.Track) | t.pos not in Track implies always t.pos not in Track)
prop3 U: always pos = pos and (always all t : (Train - pos.Track) | t.pos not in Track implies always t.pos not in Track)
prop3 C: always pos' = pos
prop3 U: always ^pos = pos
prop3 C: always pos' = pos
prop4 B: always prox.~prox in iden
prop4 B: always ~prox.prox in iden
prop4 C: always pos.~pos in iden
prop5 U: always all t : Train | (t.pos).prox = Exit releases t.pos.prox in Track
prop5 B: always all t : Train | some t1 : Track | t.pos = t1 implies after t.pos in (t1.prox + t1)

