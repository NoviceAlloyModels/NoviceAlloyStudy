NA H: THEME UPDATE
inv11 C: always ( all t:Train | some t.pos implies once some t.pos :> Entry)
inv13 O: always ( all t:Train | no t.pos implies always (no t.pos))
inv13 B: ( all t:Train | no t.pos implies always (no t.pos))
inv13 O: always ( all t:Train | no t.pos implies always (no t.pos))
inv13 B: always ( all t:Train | eventually always no t.pos implies  always(no t.pos))
inv13 B: ( all t:Train | eventually always no t.pos implies  always(no t.pos))
inv13 B: ( all t:Train | no t.pos since  no t.pos)
inv13 O: always ( all t:Train | no t.pos since  no t.pos)
inv15 S: eventually always t.pos !=t.pos'
inv5 E: 
inv5 E: 
inv15 O: eventually always (all t: Train| t.pos != t.pos')
inv15 B: eventually always (some t: Train| t.pos != t.pos')
inv15 B: eventually always (some t: Train| (no t.pos  implies some t.pos) or t.pos != t.pos')
inv15 B: always (some t: Train| (no t.pos  implies some t.pos) or t.pos != t.pos')
inv15 B: eventually always (some t: Train| (no t.pos  implies some t.pos) or t.pos != t.pos')
inv15 B: eventually always (some t: Train| (no t.pos  implies eventually some t.pos) or t.pos != t.pos')
inv15 B: always (some t: Train| (no t.pos  implies eventually some t.pos) or t.pos != t.pos')
inv15 B: always (some t: Train| (no t.pos  implies eventually some t.pos) or eventually t.pos != t.pos')
inv15 B: eventually always (pos != pos')
inv15 B: eventually always some pos =>(pos != pos')
inv15 B: eventually always (some pos =>(pos != pos'))
inv15 U: always eventually (some pos =>(pos != pos'))
inv15 B: always eventually (pos != pos')
inv15 B: always eventually some Train and (pos != pos')
inv15 B: always eventually some pos and (pos != pos')
inv15 B: always eventually (some pos and (pos != pos'))
inv14 S: always ( all t:Train | some t.pos and some (t.pos.signal :>Green) implies (t.pos'.signal in  Siganl-Green)
inv14 S: always ( all t:Train | (some t.pos and some (t.pos.signal :>Green) )implies (t.pos'.signal in  Siganl-Green) )
inv14 B: always ( all t:Train | (some t.pos and some (t.pos.signal :>Green) )implies (t.pos'.signal in  Signal-Green) )
inv14 S: always ( all t:Train | (some t.pos and one t.pos.signal some (t.pos.signal :>Green) )implies (t.pos'.signal in  Signal-Green) )
inv14 B: always ( all t:Train | (some t.pos and one t.pos.signal and some (t.pos.signal :>Green) )implies (t.pos'.signal in  Signal-Green) )
inv14 B: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) )implies (t.pos'.signal in  Signal-Green) )
inv14 O: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) )implies (t.pos.signal in  Signal-Green) )
inv14 O: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) and t.pos != t.pos' )implies (t.pos.signal in  Signal-Green) )
inv14 O: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green)  )implies (t.pos != t.pos' and t.pos.signal in  Signal-Green) )
inv14 O: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) and t.pos != t.pos' )implies (t.pos.signal in  Signal-Green) )
inv14 B: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) and no t.pos' )implies (t.pos.signal in  Signal-Green) )
inv14 U: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) and no t.pos' )implies (t.pos'.signal in  Signal-Green) )
inv14 B: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) )implies (t.pos'.signal in  Signal-Green) )
inv14 B: always ( all t:Train | ( one (t.pos.signal :>Green) )implies (t.pos'.signal in  Signal-Green) )
inv14 O: always ( all t:Train | ( one (t.pos.signal :>Green) )implies (t.pos.signal in  Signal-Green) )
inv14 B: always ( all t:Train | ( one (t.pos.signal :>Green) )implies after (t.pos.signal in  Signal-Green) )
inv14 B: always ( all t:Train | (some t.pos' and  one (t.pos.signal :>Green) )implies after (t.pos.signal in  Signal-Green) )
inv14 B: always ( all t:Train | ( one (t.pos.signal :>Green) )implies after (t.pos.signal in  Signal-Green) )
inv14 B: always ( all t:Train | ( one (t.pos.signal :>Green) )implies eventually (t.pos.signal in  Signal-Green) )
inv14 B: always ( all t:Train | let tr=t.pos | ( one (tr.signal :>Green) )implies after (tr.signal in  Signal-Green) )
inv14 B: always ( all t:Train | let tr=t.pos |pos!=pos' and ( one (tr.signal :>Green) )implies after (tr.signal in  Signal-Green) )
inv14 B: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) )implies after (t.pos.signal in  Signal-Green) )
inv14 B: ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) )implies after (t.pos.signal in  Signal-Green) )
inv14 B: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) )implies after (t.pos.signal in  Signal-Green) )
inv14 S: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) ) implies (eventually t.pos'!=t.pos and (t.pos.signal in  Signal-Green) )
inv14 O: always ( all t:Train | (some t.pos and  one (t.pos.signal :>Green) ) implies (eventually t.pos'!=t.pos and (t.pos.signal in  Signal-Green) ))
inv14 T: always ( all t:Train | eventually (some t.pos  and  one (t.pos.signal :>Green) and t.pos'!=pos ) implies (t.pos.signal in  Signal-Green) )
inv14 O: always ( all t:Train | eventually (some t.pos  and  one (t.pos.signal :>Green) and t.pos' !=t. pos ) implies (t.pos.signal in  Signal-Green) )
inv14 B: always ( all t:Train | eventually (some t.pos  and  one (t.pos.signal :>Green) and t.pos' !=t. pos and some t.pos' ) implies (t.pos.signal in  Signal-Green) )
inv14 B: always ( all t:Train | eventually (some t.pos  and  one (t.pos.signal :>Green) and t.pos' !=t. pos and some t.pos') implies (t.pos.signal in  Signal-Green) )
inv14 B: always ( all t:Train | eventually (some t.pos  and  one (t.pos.signal :>Green) and t.pos' !=t. pos and some t.pos') implies (t.pos.signal in  Signal-Green) )
inv15 B: always eventually pos!=pos'
inv15 B: always eventually pos!=pos'
inv15 U: always eventually (some pos implies pos!=pos'  )
inv15 B: always eventually (some Train  implies Train.pos!=Train.pos' )
inv15 C: always eventually (all t:Train | (no t.pos => eventually some t.pos ) and some t.pos => eventually (t.pos !=t.pos')   )
inv13 C: always (all t:Train | (once some t.pos and no t.pos ) => always no t.pos)
inv16 C: always (all t:Train | one (t.pos:>Exit) => (some t.pos since one (t.pos:>Entry )))
inv17 T: always ( one (Train.pos) => before Train.pos:>Exit )
inv17 T: always ( one (Train.pos) =>  Train.pos:>Exit )
inv17 E: 
inv17 T: ( one (Train.pos) =>  Train.pos:>Exit )
inv17 T: always ( one pos =>  Train.pos:>Exit )
inv17 T: ( one pos =>  Train.pos:>Exit )
inv17 B: ( one pos =>  no pos)
inv17 B: ( one pos => one Train.pos:>Exit )
inv17 O: always( one pos => one Train.pos:>Exit )
inv17 B: always( one Train.pos:>Exit  since one pos  )
inv17 B: ( one pos => one Train.pos:>Exit )
inv9 S: always (all t:Train| eventually (some t.pos:>Entry )
inv9 B: always (all t:Train| eventually (some t.pos:>Entry ))
inv9 B: always (all t:Train| eventually (no t.pos and one t.pos':>Entry))
inv9 B: always (all t:Train| eventually (no t.pos and one t.pos':>Entry))
inv9 B: always (all t:Train| eventually ( one t.pos':>Entry))
inv9 B: always (all t:Train| eventually ( one t.pos:>Entry))
inv9 B: always (all t:Train| eventually (no t.pos and after one t.pos:>Entry))
inv9 B: (all t:Train| eventually (no t.pos and after one t.pos:>Entry))
inv9 O: (all t:Train| eventually (historically no t.pos and after one t.pos:>Entry))
inv9 O: (all t:Train|  (historically no t.pos and after one t.pos:>Entry))
inv9 O: always (all t:Train|  (no t.pos and after one t.pos:>Entry) )
inv9 O: eventually  always (all t:Train|  (no t.pos and after one t.pos:>Entry) )
inv9 O: (all t:Train|  once(no t.pos and after one t.pos:>Entry) )
inv9 O: always  (all t:Train|  once(no t.pos and after one t.pos:>Entry) )
inv9 B: always  (all t:Train|  once(no t.pos => after one t.pos:>Entry) )
inv9 O: always  (all t:Train|  once(no t.pos and after one t.pos:>Entry) )
inv9 B: always  (all t:Train|  eventually (no t.pos => after one t.pos:>Entry) )
inv9 U: (all t:Train|  eventually (no t.pos => after one t.pos:>Entry) )
inv9 B: (all t:Train|  eventually (no t.pos and after one t.pos:>Entry) )
inv9 U: (all t:Train|  eventually ( one t.pos:>Entry) )
inv9 U: (all t:Train|  eventually ( some t.pos and one t.pos:>Entry) )
inv9 B: (all t:Train|  eventually ( before no t.pos and one t.pos:>Entry) )
inv9 B: (all t:Train|  eventually ( no t.pos and after ( one t.pos:>Entry)) )
inv9 B: always(all t:Train|  eventually ( no t.pos and after ( one t.pos:>Entry)) )
inv9 B: always(all t:Train|  eventually ( before no t.pos and after ( one t.pos:>Entry)) )
inv9 O: (all t:Train|  eventually always  ( no t.pos and after ( one t.pos:>Entry)) )
inv9 S: (all t:Train|  no t.pos => eventually ( one t.pos':>Entry)) )
inv9 S: (all t:Train|  no t.pos => after ( one t.pos':>Entry)) )
inv9 S: (all t:Train|  no t.pos  after ( one t.pos':>Entry)) )
inv9 S: (all t:Train|  (no t.pos  after ( one t.pos':>Entry)) )
inv9 S: (all t:Train|  (no t.pos  after  one (t.pos':>Entry)  )
inv9 S: (all t:Train| eventually (no t.pos  after  one (t.pos':>Entry))
inv9 S: (all t:Train| eventually (no t.pos  after  one (t.pos':>Entry)) )
inv9 S: (all t:Train|  (no t.pos  after  one (t.pos':>Entry)) )
inv9 S: always (all t:Train|  (no t.pos  after  one (t.pos':>Entry)) )
inv9 B: always (all t:Train|  (no t.pos =>  one (t.pos':>Entry)) )
inv9 B: always (all t:Train| eventually (no t.pos =>  one (t.pos':>Entry)) )
inv5 S: always (all t:Train|(one t.pos:> Exit => no t.pos)  or (one t.pos  => t.pos' in t.pos.prox  )
inv5 S: always (all t:Train|(one t.pos:> Exit => no t.pos)  or (one t.pos  => t.pos' in t.pos.prox  )
inv5 B: always (all t:Train|(one t.pos:> Exit => no t.pos)  or (one t.pos  => t.pos' in t.pos.prox  ) )
inv5 U: always (all t:Train|(one t.pos:> Exit => no t.pos)  or (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox  ) )
inv5 U: always (all t:Train|(one t.pos:> Exit => no t.pos')  or (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox  ) )
inv5 U: always (all t:Train|(one t.pos:> Exit => no t.pos')  or (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox  ) )
inv5 B: always (all t:Train|(one t.pos:> Exit => no t.pos')  or (one t.pos  => t.pos' in t.pos.prox  ) )
inv5 U: always (all t:Train|(one t.pos:> Exit => no t.pos')  or (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox  ) )
inv5 U: always (all t:Train|(one t.pos:> Exit => no t.pos')  or (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox  ) or pos'=pos )
inv5 U: always (all t:Train|(one t.pos:> Exit => no t.pos')  or (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox  ) )
inv5 U: always (all t:Train|(one t.pos:> Exit => no t.pos')	or (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox  )	or  no t.pos.prox  => (no t.pos' or t.pos=t.pos')   )
inv5 U: always (all t:Train|(one t.pos:> Exit => no t.pos')	or (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox  )	or  no t.pos.prox  => (no t.pos' or t.pos=t.pos')   )
inv5 S: always (all t:Train|(one t.pos:> Exit => no t.pos'))	always (all t:Train| (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox )	always (all t:Train| no t.pos.prox  => (no t.pos' or t.pos'=t.pos)   )
inv5 B: always (all t:Train|(one t.pos:> Exit => no t.pos'))	always (all t:Train| (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox ) )	always (all t:Train| no t.pos.prox  => (no t.pos' or t.pos'=t.pos) )
inv5 B: always (all t:Train|(one t.pos:> Exit => no t.pos'))	always (all t:Train| (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox ) )	always (all t:Train| (no t.pos.prox and one t.pos:> Track-Exit)  => (no t.pos' or t.pos'=t.pos) )
inv5 B: always (all t:Train|(one t.pos:> Exit => no t.pos'))	always (all t:Train| (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox ) )	always (all t:Train| (no t.pos.prox and one t.pos:> Track-Exit) => (no t.pos' or t.pos'=t.pos) )
inv5 B: always (all t:Train|(one t.pos:> Exit and  some t.pos.prox  => no t.pos'))	always (all t:Train| (one t.pos and some t.pos.prox  => t.pos' in t.pos.prox ) )
inv5 S: always (all t:Train|(one t.pos:> Exit and  some t.pos.prox  => no t.pos'))	always (all t:Train| (one t.pos and some t.pos.prox  => (t.pos' in t.pos.prox or t.pos=t.pos') )
inv5 S: always (all t:Train|(one t.pos:> Exit and  some t.pos.prox  => no t.pos'))	always (all t:Train| (one t.pos and some t.pos.prox  => (t.pos' in t.pos.prox or t.pos'=t.pos) )
inv5 U: always (all t:Train|(one t.pos:> Exit and  some t.pos.prox  => no t.pos'))	always (all t:Train| (one t.pos and some t.pos.prox ) => (t.pos' in t.pos.prox or t.pos'=t.pos) )
inv5 B: always (all t:Train|(one t.pos:> Exit  => no t.pos'))	always (all t:Train| (one t.pos and some t.pos.prox ) => (t.pos' in t.pos.prox or t.pos'=t.pos) )
inv5 U: always (all t:Train|(one t.pos:> Exit  => no t.pos')) or	always (all t:Train| (one t.pos and some t.pos.prox ) => (t.pos' in t.pos.prox or t.pos'=t.pos) )
inv17 B: one Train.pos:>Exit  since one pos
inv17 B: some pos => one Train.pos:>Exit  since one pos
inv17 B: some Train => (one Train.pos:>Exit  since one pos)
inv17 B: always (some Train => (one Train.pos:>Exit  since one pos))
inv17 B: some Train => (one Train.pos:>Exit  since one pos)
NA H: THEME UPDATE
NA H: THEME UPDATE

